"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var linez = require("linez");
function updateDoc(doc, settings) {
    doc.lines = doc.lines.map(function (rawLine) {
        return new Line(rawLine, doc);
    });
    if (!settings || !settings.block_comment_start || !settings.block_comment_end) {
        return doc;
    }
    var block_comment = settings.block_comment;
    if (!block_comment &&
        settings.block_comment_start[settings.block_comment_start.length - 1] === settings.block_comment_end[0]) {
        block_comment = settings.block_comment_end[0];
    }
    var padSize = 0;
    if (block_comment) {
        padSize = Math.max(0, settings.block_comment_start.indexOf(block_comment));
    }
    var docCommentLines;
    doc.lines.forEach(function (line) {
        if (_.startsWith(line.string, settings.block_comment_start)) {
            docCommentLines = [line];
        }
        else if (_.endsWith(line.string, settings.block_comment_end)) {
            if (docCommentLines) {
                var blockCommentStart = docCommentLines[0];
                blockCommentStart.isBlockCommentStart = true;
                var commentStartWidth = settings.block_comment_start.length;
                var currPadSize = /^\s*/.exec(blockCommentStart.string.slice(commentStartWidth))[0].length || 1;
                currPadSize += commentStartWidth;
                line.isBlockCommentEnd = true;
                docCommentLines.push(line);
                docCommentLines.forEach(function (line) {
                    if (block_comment && _.startsWith(line.string, block_comment)) {
                        line.padSize = padSize;
                        line.isBlockComment = true;
                    }
                    else if (line.isBlockCommentStart) {
                        return;
                    }
                    else {
                        line.padSize = currPadSize;
                    }
                    line.blockCommentStart = blockCommentStart;
                });
            }
            docCommentLines = null;
        }
        else if (docCommentLines) {
            docCommentLines.push(line);
        }
        return line;
    });
    return doc;
}
var Line = (function () {
    function Line(line, doc) {
        this.isBlockComment = false;
        this.isBlockCommentEnd = false;
        this.isBlockCommentStart = false;
        this.blockCommentStart = null;
        this.padSize = 0;
        for (var prop in line) {
            this[prop] = line[prop];
        }
        if (doc) {
            this.doc = doc;
        }
    }
    Object.defineProperty(Line.prototype, "text", {
        get: function () {
            return this.prefix + this.string + this.suffix;
        },
        set: function (text) {
            var textArray = /^([\t ]*)(.*?)([\t ]*)$/.exec(text);
            if (textArray && textArray[2]) {
                this.prefix = textArray[1];
                this.string = textArray[2];
                this.suffix = textArray[3];
            }
            else {
                this.prefix = '';
                this.string = '';
                this.suffix = text;
            }
        },
        enumerable: true,
        configurable: true
    });
    return Line;
}());
exports.Line = Line;
function create(file, settings) {
    var document = (linez(file));
    updateDoc(document, settings);
    return document;
}
exports.create = create;
//# sourceMappingURL=doc.js.map